#!/bin/bash
###############################################################################
# Name: MacLemon Backup
# Author: Pepi Zawodsky
# eMail: pepi@maclemon.at
# Copyright 2005, 2006: All Rights reserved
# Future licensing not yet decided (GPL, LGPL or BSD are likely) Suggestions?
###############################################################################
# first thing we do is check the time to later see how long things took
MLtimeScriptStart=$(date +%s)
###############################################################################
# Debug Mode. Set to 1 to get some debug messages set to 0 to skip them.
MLdebug=0
###############################################################################
# determining a few standard variables for comfortable use later
MLfullCommand=$0
MLbaseCommand=$(basename $0)
###############################################################################
# Error and exit codes used
# Everything Ok returns 0
# Any rsync error returns the return value of rsync
# Known rsync error codes are 1-30
# Any other error returns one of these (128-254):
MLE_DestinationNotWriteable=250
MLE_NoConfigFileParameter=251
MLE_DestinationIsNoDirectory=252
MLE_ConfigFileNotReadable=253
MLE_ConfigFileNotFound=254
###############################################################################
# Check if we run as root and set MLweAreRoot accordingly. Other parts of the script can rely on this variable to be set correctly.
MLrootUID=0
if [ "$UID" -ne "$MLrootUID" ]
	then # I am not root
		MLweAreRoot=0
		
	else # Bow before me, for I am root!
		MLweAreRoot=1
fi
###############################################################################
# defining our own functions:

function appendToFile (){
# Appends a given text at the end of a given file
# usage: appendToFile "path/to/filename" "Message to append"
# caveat: No error checking yet (should check for existence of file and writeability, should output to console in case of problems)
	echo "$2" >> "$1"
}

#------------------------------------------------------------------------------
# function prependToFile (){
# Prepends a given Text at the beginning of a given file
# usage: prependToFile "path/to/filename" "Message to prepend"
# caveat: No error checking yet
	
# Pushed back a moment, current found solutions are not elegant and require at least 
# one second temporary file.

# }

#------------------------------------------------------------------------------
function debug (){
# outputs a debugging message to console if the MLdebug Flag is set to 1
# usage: debug "Your debugging Message"
	if [ $MLdebug -eq 1 ] # Is the debug flag set?
	then # Output everything that is passed to stdout:
		MLtheDebugMessage="$(date) $MLbaseCommand[$$] DEBUG: $@"
		echo $MLtheDebugMessage
		
		# same message passed to the admin eMail Message
		appendToFile "$MLadminEmailMessage" "$MLtheDebugMessage"
	fi
}
###############################################################################
# Creating a few temporary files we need

MLadminEmailMessage=$(mktemp -t MLadminEmailMessage.XXXXXXXXXX) # Email composition for Backup Admin
debug "MLadminEmailMessage = $MLadminEmailMessage"

# If the backup only takes place on localhost we should probably directly
# create the logfiles in the backup destination (which we would need to create
# ourselves instead of letting rsync do the job.) 
MLrsyncLogFile=$(mktemp -t MLrsyncLogFile.XXXXXXXXXX) # Logfile for rsync LOG 
debug "MLrsyncLogFile = $MLrsyncLogFile"

MLrsyncErrFile=$(mktemp -t MLrsyncErrFile.XXXXXXXXXX) # Logfile for rsync ERR
debug "MLrsyncErrFile = $MLrsyncErrFile"

###############################################################################
# Setting our own internal variables.
# To be improved. Some of these may be moved to the config file later.

# Path to rsync
MLrsync="/usr/bin/rsync" # For Mac OS X Tiger (10.4 and up)
MLsourceRsync=$MLrsync
MLdestRsync="--rsync-path=$MLrsync"

# Dry run, for debugging Rsync, does NOT alter any files, only pretends to.
# MLdryRun=-n

# The options to invoke rsync with.
MLrsyncOptions="-apogt"

#Rsync should use compression for non-local-only backup transport (SSH)
MLrsyncCompress="--compress"

# Rsync should be verbose
# Rsync verbosity beyond -vv does NOT seem to work on Mac OS X, I am afraid this is an rsync bug
MLbeVerbose="-vv"

# Delete trashed files from the backup so our backups don't grow infinitely?
MLdelete="--delete"

# Exclude Paths and Filenames mentioned in this file.
MLexcludeFrom="--exclude-from=/etc/maclemon/backup/globalexclusions"
# These are our global settings, user exclusion file will be available at a later date.

# Be nice to other processes when compressing the logs
# See man nice(1) for levels of niceness
MLbeNice=20
# should check if MLbeNice is an integer in the range of -20 < MLbeNice < +20.

if [ "$MLbeNice" -eq 0 ]
then # nice is zero, so we do not alter the task priority
	MLbeNiceCommand=""
else # nice is non zero
	if [ "$MLbeNice" -gt 0 ]
	then # We can always lower the priority of the tasks
		MLbeNiceCommand="/usr/bin/nice -n $MLbeNice "
	else 
		if [ $MLweAreRoot -eq 1 ]
		then # We can only increase the priority if we are running as root
			MLbeNiceCommand="/usr/bin/nice -n $MLbeNice "			
		else # We are not root, so we will not change the priority, but tell the admin
			MLbeNiceCommand=""
			# Adding a message to the admin notification eMail
			appendToFile "$MLadminEmailMessage"  "
INFO: The requested increased priority of $MLbeNice for $MLbaseCommand could not be set since we are not running as root. Either set the variable MLbeNice to a non negative integer value or run $MLbaseCommand as root.
See man nice(1) for more info.
"
# End of message. Take care of the quotes!
		fi # [ $MLweAreRoot -eq 1 ]
	fi # [ $MLbeNice > 0 ]
fi # [ $MLbeNice -eq 0 ]
debug "MLbeNice = $MLbeNice ; MLbeNiceCommand = $MLbeNiceCommand"
###############################################################################
# Including other external scripts, this will be improved in the future

. /usr/local/bin/growler.sh # Provides a handy growlnotify function, see script for info!
###############################################################################
# Getting the configuration file
# Handling of the config file should be a little more elegant.

# Did we get a parameter to use as a config file?
if [ -z "$1" ]
then # There was no config filename passed
  echo "Usage: $MLbaseCommand path/to/configfile"
  exit $MLE_NoConfigFileParameter # Error invoking backlemon. Cannot continue without a config.
else # We were passed a config file
	MLconfigFile=$1
	debug "Config file to use is: $MLconfigFile"

	# Now let's check that parameter
	# Does this file exist?
	if [ -e $MLconfigFile ]
	then # The file does exist 
		debug "Config file $MLconfigFile exists."
		
		# Is the config file readable by the user invoking the script?
		if [ -r $MLconfigFile ]
		then # The config file can be read by the user invoking this script

			# Load in the config (DIRTY *yuck*) Better use the defaults system
			debug "Loading the config file $MLconfigFile"
			. $MLconfigFile
		else # The user does not have read permission for the config file
			echo $MLbaseCommand[$$]:FATAL The config file $MLconfigFile does exist but is not readable by $USER. Please change the mode or owner of the configuration file or use a different user to run $MLbaseCommand!
			exit $MLE_ConfigFileNotReadable # config file not readable
			# We might do further testing of this file to give a better error
		fi
	else # The config file doesn't exist, FATAL
		echo $MLbaseCommand[$$]:FATAL The config file $MLconfigFile could not be found. Please check the path!
		exit $MLE_ConfigFileNotFound # Config file not found
	fi # [ -e $MLconfigFile ]
fi # [ -z "$1" ]
###############################################################################
# If we're running as root we create a .pid file in /var/run
# This should be substantially improved so we write different .pid files for different invocations of backlemon. (Depending on configuration)
if [ "$MLweAreRoot" -eq "1" ]
then # We are root, so let us create a .pid file
	MLmyPidFile="/var/run/"$MLbaseCommand".pid"
	echo $$ > $MLmyPidFile
fi # [ "$MLweAreRoot" -eq "1" ]
# This .pid file is removed at the end of the script
# Would be nice to be able to write .pid files if not beeing root as well.
###############################################################################
# Sanitizing of Input to variables.
#
# error handling of config file, setting defaults for missing parameters
###############################################################################
# FUTURE: Preflight scripts will be called from here.
###############################################################################
# asking rsync to tell us how to use extended Attributes (HFS, ResForks)
MLextendedAttributes=$($MLsourceRsync --help | grep -e "extended" -e "attributes" | sed -e 's/^.*--/--/' -e 's/\ .*//')

# checking target

if [ ! -e "$MLdestPath" ] # Does our target directory exist?
then
	# we should check with -d here! exists AND is Dir. Error handling later
	# The target directory does not exist, we will try to create it.
	echo The target Directory does not exist, trying to create one
	MLeCreateDirectoryReturn=0
	mkdir -m 750 "$MLdestPath"
	# removed -p from Target creation, should help with missing target Volumes
	MLeCreateDirectoryReturn=$?
	if [ "$MLeCreateDirectoryReturn" ]	# Did that go well?
	then
	# No, an error occured
		MLtheFinalErrorMessage="The target directory $MLdestPath does not exist and an attempt to create it failed. You may want to check the privileges."
		echo $MLtheFinalErrorMessage
		exit
	fi
else
	if [ -d "$MLdestPath" ] # The destination does exist AND is a directory
	then
		# check if it is writeable!
		# if yes ok, else fail
		if [[ -r "$MLdestPath" && -w "$MLdestPath" && -x "$MLdestPath" ]] # Can we rwx the destination? We need it.
		then
			debug "The destination $MLdestPath offers all privs we need."
		else
			echo "The destination $MLdestPath need read, write and execute privs for the user $USER invoking this script to be able to backup your data."
			exit $MLE_DestinationNotWriteable
		fi
	else
		echo "$MLbaseCommand: The destination $MLdestPath is not a directory. We can not save backups in anything but a directory (like a file or block device)"
		exit $MLE_DestinationIsNoDirectory
	fi
fi

# We need to find the most recent Backup as our Target for the link-dest
# The grep shoud be a much better regexp, so we do not accidentally use a LIKE named other backup, but actually a correct old backup to refer to. Currently this will incorrectly find partial names as well as extended names!
# FIX THIS!
MLmostRecentSet=$(ls -1tw "$MLdestPath/" | grep "^$MLbackupName-" | head -1)
debug "The most Recent Set to refer to is: $MLmostRecentSet"


MLgrowlNotifyDelay=10
# notifying our user of the pending backup
if [ $MLdebug -eq 0 ] # Are we in debug mode?
then	# We are NOT in debug mode, so we display a growl and wait a moment
	growlnotify -n BackLemon -m "Your Backup will start in $MLgrowlNotifyDelay Seconds" -t "BackLemon starting"
	sleep $MLgrowlNotifyDelay
fi


#Fetching the current date and time
MLbackupDate=$(date "+%Y.%m.%d-%H.%M.%S")
debug "Rsync starting now."

MLtimeRsyncStart=$(date +%s)
# backing up

$MLsourceRsync $MLbeVerbose $MLdestRsync $MLrsyncOptions $MLrsyncCompress $MLdryRun $MLextendedAttributes $MLdelete $MLexcludeFrom --link-dest="$MLdestPath/$MLmostRecentSet/" "$MLsourcePath" "$MLdestPath/$MLbackupName-$MLbackupDate/" >$MLrsyncLogFile 2>$MLrsyncErrFile
MLbackupStatus=$? # Fetching the return code from our rsync command
MLtimeRsyncEnd=$(date +%s) # Fetching a timestamp after rsync for timing stats

let "MLtimeRsyncDuration = $MLtimeRsyncEnd - $MLtimeRsyncStart"
if [ $MLtimeRsyncDuration -eq 1 ] # Just to care for proper language
then # It was only one second
	debug "rsync took $MLtimeRsyncDuration second."
else # zero, two or more seconds
	debug "rsync took $MLtimeRsyncDuration seconds."
fi

###############################################################################
# Post processing the recorded logfiles:
# We move and compress the logfiles to the backup destination. (currently only on localhost)
debug "Compressing the logfiles and moving them to the backup destination."

# Postprocessing the error.log
if [ -s $MLrsyncErrFile ] # Non zero byte error.log? Only in case of errors
then # Yes, there were errors recorded.
	$MLbeNiceCommand cat $MLrsyncErrFile | gzip -9 >$MLdestPath/$MLbackupName-$MLbackupDate/error.log.gz
else
	debug "The error.log $MLrsyncErrFile was empty, looks good."
fi # [ -s $MLrsyncErrFile ]
# removing the error.log tempfile
rm $MLrsyncErrFile

# post processing the rsync.log
if [ -s $MLrsyncLogFile ] # Non zero bytes rsync.log? (Expected)
then # Yes, of course, compress and move to the backup folder
	$MLbeNiceCommand cat $MLrsyncLogFile | gzip -9 >$MLdestPath/$MLbackupName-$MLbackupDate/rsync.log.gz
else
	debug "The rsync.log $MLrsyncLogFile was empty, this is extremely unlikely!"
fi #[ -s $MLrsyncLogFile ]
# Removing the rsync.log tempfile
rm $MLrsyncLogFile


###############################################################################
# Post processing of the backup:

case $MLbackupStatus in
	0)	# The last backup went ok
		# If there is setlabel installed, we color it green (green is good)
		MLeRsyncErrorMessage=""
		addToFile "$MLadminEmailMessage" "Rsync returned $MLbackupStatus 
		The Backup $MLbackupName went OK!"
		MLsetlabelPath=$(which setlabel)
		if [ -e $MLsetlabelPath ] # only makes it green if setlabel command is installed
		then
			$MLsetlabelPath Green "$MLdestPath/$MLbackupName-$MLbackupDate/"
		fi
		
		# If we have setfcomment installed, we add a nice comment to the folder
		MLsetfcommentPath=$(which setfcomment)
		if [ -e $MLsetfcommentPath ] # Is setfcomment intalled?
		then
			setfcomment -c "Created by $MLbaseCommand $MLversion. Invoked by $USER on $MLbackupDate from Source: $MLsourcePath" "$MLdestPath/$MLbackupName-$MLbackupDate/"
		fi
		
		# notifying our user that the backup finished successfully
		growlnotify -n BackLemon -m "The Backup $MLbackupName was successful." -t "BackLemon finished"
		
		# checking if we need to remove some old ones
		MLoldBackupCount=$(ls -1w "$MLdestPath/" | grep -c "^$MLbackupName-")
	
		debug "Old Backup Count: $MLoldBackupCount"
		if [ "$MLoldBackupCount" -gt "$MLbackupCount" ] # There are surplus Backups, so we remove them
		then
			debug "There are surplus old backups, starting to remove them."
			for ((MLloopIndex="$MLoldBackupCount" ; MLloopIndex>"$MLbackupCount" ; MLloopIndex-- ))
			do
			# Counting down
			MLoldestSetToBeRemoved=$(ls -1trw "$MLdestPath/" | grep "^$MLbackupName-" | head -1)
			debug "Removing the Set named: $MLdestPath/$MLoldestSetToBeRemoved"
			rm -r "$MLdestPath/$MLoldestSetToBeRemoved"
			# We should check if removing an oldbackup worked correctly, if a user has set the
			# locked bit, rm will fail on that file, which will take up space over time. and more important will have this part looooop and hang. Maybe better write them all to an array and try to delete in one rush.
			done
		fi
	debug "BackLemon was successful!"
	;;
	# Error Codes we know from the rsync man page
	1) MLeRsyncErrorMessage="Syntax or usage error" ;;
	2) MLeRsyncErrorMessage="Protocol incompatibility" ;;
	3) MLeRsyncErrorMessage="Errors selecting input/output files, dirs" ;;
	4) MLeRsyncErrorMessage="Requested action not supported: an attempt was made to manipulate 64-bit files on a platform that cannot support them; or an option was specified that is supported by the client and not by the server." ;;
	5) MLeRsyncErrorMessage="Error starting client-server protocol";;
	6) MLeRsyncErrorMessage="Daemon unable to append to log-file" ;;
	10) MLeRsyncErrorMessage="Error in socket I/O" ;;
	11) MLeRsyncErrorMessage="Error in file I/O" ;;
	12) MLeRsyncErrorMessage="Error in rsync protocol data stream" ;;
	13) MLeRsyncErrorMessage="Errors with program diagnostics" ;;
	14) MLeRsyncErrorMessage="Error in IPC code" ;;
	20) MLeRsyncErrorMessage="Received SIGUSR1 or SIGINT" ;;
	21) MLeRsyncErrorMessage="Some error returned by waitpid()" ;;
	22) MLeRsyncErrorMessage="Error allocating core memory buffers" ;;
	23) MLeRsyncErrorMessage="Partial transfer due to error" ;;
	24) MLeRsyncErrorMessage="Partial transfer due to vanished source files" ;;
	25) MLeRsyncErrorMessage="The --max-delete limit stopped deletions" ;;
	30) MLeRsyncErrorMessage="Timeout in data send/receive";;

	# Any other error that might have occured that is unspecified
	*) MLeRsyncErrorMessage="$0: Rsync returned Error Code $MLbackupStatus: Sorry, we do not know what this error code means. You may want to check your logfiles or the man page for rsync on your system."
	;;
esac


debug "Rsync returned $MLbackupStatus: $MLeRsyncErrorMessage"
addToFile "$MLadminEmailMessage" "Rsync returned $MLbackupStatus $MLeRsyncErrorMessage"

if [ $MLbackupStatus -ne 0 ] # Something went wrong during the backup
then
	# Telling that something went wrong
	debug "Rsync returned $MLbackupStatus: $MLeRsyncErrorMessage"
	
	# If there is setlabel installed, we color it red (red like a warning)
	MLsetlabelPath=$(which setlabel)
	if [ -e $MLsetlabelPath ] # only makes it red if setlabel command is installed
	then
		$MLsetlabelPath Red "$MLdestPath/$MLbackupName-$MLbackupDate/"
	fi # [ -e $MLsetlabelPath ]

	# If we have setfcomment installed, we add a nice comment to the folder
	# TODO: Comment should be truncated to less than 200 characters.
	MLsetfcommentPath=$(which setfcomment)
	if [ -e $MLsetfcommentPath ] # Is setfcomment intalled?
	then
		setfcomment -c "Unfinished backup! Rsync returned $MLbackupStatus: $MLeRsyncErrorMessage Created by $MLbaseCommand $MLbacklemonVersion($MLbacklemonBuild). Invoked by $USER on $MLbackupDate from Source: $MLsourcePath" "$MLdestPath/$MLbackupName-$MLbackupDate/"
	fi # [ -e $MLsetfcommentPath ]

	# renaming the unfinished backup, so it will notbe used for the next delta backup!	
	mv "$MLdestPath/$MLbackupName-$MLbackupDate" "$MLdestPath/ERROR-$MLbackupName-$MLbackupDate"
	
	# notifying our user of the backup ERROR
growlnotify -n BackLemon -m "$MLeRsyncErrorMessage" -s -t "$MLbackupName Error $MLbackupStatus"

	else
	# notifying the user of the completed and successful backup
	growlnotify -n BackLemon -m "$MLbackupName completed successfully." -s -t "Backup $MLbackupName finished"
fi #[ $MLbackupStatus -ne 0 ]


# At the moment we just move the MLadminEmailMessage into the Backup Dir
# No emailing yet 
# BUG: Breaks if Backup was renamed due to error...
# I should REALLY improve on Backup error postprocessing. *embarrassing*
if [ -s $MLadminEmailMessage ] # admin eMail message greater than 0 bytes?
then # Yes, something is in the Message file
	# So we move it to the Backup Directory and rename it accordingly
	mv $MLadminEmailMessage $MLdestPath/$MLbackupName-$MLbackupDate/AdminEMail.txt
else # No, the message is empty, very unlikely
	# nothing to shout about, so we silently remove the temporary file
	rm $MLadminEmailMessage
fi

# cleaning up, or so
# FUTURE: Postflight script

###############################################################################
# Almost last thing is to determine how long the backup took.
MLtimeScriptEnd=$(date +%s)

#Calculating the time difference between start and end giving us the duration
let "MLtimeScriptDurationTotal = $MLtimeScriptEnd - $MLtimeScriptStart"

if [ $MLtimeScriptDurationTotal -eq 1 ] # Just to care for proper language
then # It was only one second
	debug "Backup took $MLtimeScriptDurationTotal second."
else # zero, two or more seconds
	debug "Backup took $MLtimeScriptDurationTotal seconds."
fi

# sending the admin eMail Notification
MLhostname=$(hostname)
cat $MLdestPath/$MLbackupName-$MLbackupDate/AdminEMail.txt | mail -s "$MLhostname $MLbackupName Report $MLbackupStatus" $MLadminEmail


if [ "$MLweAreRoot" -eq "1" ]
then
	# We are root, so we did create a .pid file, now let us remove it again.
	rm $MLmyPidFile
fi
debug "BackLemon ended"
###############################################################################
# EOF